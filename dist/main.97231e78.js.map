{"version":3,"sources":["main.js"],"names":["min","number","length","slice","Math","apply","minIndex","indexOf","sort","index","splice","concat","reverse","minIndexCycle","i","swap","a","b","sortCycle","console","log"],"mappings":";AAEA,IAAIA,EAAM,SAANA,EAAOC,GACHA,OAAAA,EAAOC,OAAS,EACTF,EAAI,CAACC,EAAO,GAAID,EAAIC,EAAOE,MAAM,MAEjCC,KAAKJ,IAAIK,MAAM,KAAMJ,IAUhCK,EAAW,SAACL,GAAWA,OAAAA,EAAOM,QAAQP,EAAIC,KAG1CO,EAAO,SAAPA,EAAQP,GACJA,GAAAA,EAAOC,OAAS,EAAG,CACfO,IAAAA,EAAQH,EAASL,GACjBD,EAAMC,EAAOQ,GAEV,OADPR,EAAOS,OAAOD,EAAO,GACd,CAACT,GAAKW,OAAOH,EAAKP,IAElBA,OAAAA,EAAO,GAAKA,EAAO,GAAKA,EAASA,EAAOW,WAMnDC,EAAgB,SAACZ,GAEZ,IADDK,IAAAA,EAAW,EACNQ,EAAI,EAAGA,EAAIb,EAAOC,OAAQY,IAC3Bb,EAAOa,GAAKb,EAAOK,KACnBA,EAAWQ,GAEZR,OAAAA,GAGPS,EAAO,SAACd,EAAQe,EAAGC,GAIZhB,OAHPA,EAAOe,GAAKf,EAAOe,GAAKf,EAAOgB,GAC/BhB,EAAOgB,GAAKhB,EAAOe,GAAKf,EAAOgB,GAC/BhB,EAAOe,GAAKf,EAAOe,GAAKf,EAAOgB,GACxBhB,GAIPiB,EAAY,SAACjB,GACR,IAAA,IAAIa,EAAI,EAAGA,EAAIb,EAAOC,OAAS,EAAGY,IAAK,CACxCK,QAAQC,IAAI,UACZD,QAAQC,IAASN,KAAAA,OAAAA,IAMbR,IAAAA,EAAWO,EAAcZ,EAAOE,MAAMW,IAAMA,EAChDK,QAAQC,IAAgBd,YAAAA,OAAAA,IACxBa,QAAQC,IAAWnB,OAAAA,OAAAA,EAAOK,KAEtBA,GAAYQ,GACZC,EAAKd,EAAQK,EAAUQ,GAC3BK,QAAQC,IAAenB,WAAAA,OAAAA,EAAvB,MAEGA,OAAAA","file":"main.97231e78.js","sourceRoot":"..","sourcesContent":["//返回数列的最小值\r\n//递归方法\r\nlet min = (number) => {\r\n    if (number.length > 2) {\r\n        return min([number[0], min(number.slice(1))]);\r\n    } else {\r\n        return Math.min.apply(null, number);\r\n    }\r\n};\r\n//循环方法\r\n// let minCycle = (number) => {\r\n//     return number[minIndexCycle(number)];\r\n// };\r\n\r\n//选择排序\r\n//递归方法\r\nlet minIndex = (number) => number.indexOf(min(number));\r\n\r\n//递归方法\r\nlet sort = (number) => {\r\n    if (number.length > 2) {\r\n        let index = minIndex(number);\r\n        let min = number[index];\r\n        number.splice(index, 1);\r\n        return [min].concat(sort(number));\r\n    } else {\r\n        return number[0] < number[1] ? number : number.reverse();\r\n    }\r\n};\r\n\r\n//选择排序\r\n//循环方法\r\nlet minIndexCycle = (number) => {\r\n    let minIndex = 0;\r\n    for (let i = 1; i < number.length; i++) {\r\n        if (number[i] < number[minIndex])\r\n            minIndex = i;\r\n    }\r\n    return minIndex;\r\n};\r\n\r\nlet swap = (number, a, b) => {\r\n    number[a] = number[a] ^ number[b];\r\n    number[b] = number[a] ^ number[b];\r\n    number[a] = number[a] ^ number[b];\r\n    return number;\r\n}\r\n\r\n//循环方法\r\nlet sortCycle = (number) => {\r\n    for (let i = 0; i < number.length - 1; i++) {\r\n        console.log(\"------\");\r\n        console.log(`i:${i}`);\r\n        // let tempNumber = number.slice(i);\r\n        // let minIndex = minIndexCycle(tempNumber) + i;\r\n        // 第i项及之前数列都是排好序的，只用考虑第i项之后的数列排序\r\n        // minIndexCycle(tempNumber)得到的是剔除前i项排好序数列之后的新数组中，最小数在该数组中的下标\r\n        // 由于新数组下标是重新从零开始的，要找到此最小数在number中对应的下标。应该加i。\r\n        let minIndex = minIndexCycle(number.slice(i)) + i;\r\n        console.log(`minIndex:${minIndex}`);\r\n        console.log(`min:${number[minIndex]}`);\r\n        //找到number中最小数字的下标，然后将其与当前下标的数字交换位置\r\n        if (minIndex != i)\r\n            swap(number, minIndex, i);\r\n        console.log(`number:[${number}]`);\r\n    }\r\n    return number;\r\n};\r\n"]}